<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Wordle на Русском</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root {
            --font-family: 'Nunito', sans-serif;
            --bg-color: #f4f7f8;
            --text-color: #1a1a1a;
            --modal-bg: rgba(244, 247, 248, 0.9);
            --tile-bg: #ffffff;
            --tile-border-color: #d3d6da;
            --tile-text-color: #1a1a1a;
            --key-bg: #d3d6da;
            --key-text-color: #1a1a1a;
            --header-bg: rgba(244, 247, 248, 0.8);
            --color-correct: #6aaa64;
            --color-present: #c9b458;
            --color-absent: #787c7e;
            --color-text-light: #ffffff;
            --shadow-color: rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] {
            --bg-color: #121213;
            --text-color: #ffffff;
            --modal-bg: rgba(18, 18, 19, 0.9);
            --tile-bg: #121213;
            --tile-border-color: #3a3a3c;
            --tile-text-color: #ffffff;
            --key-bg: #818384;
            --key-text-color: #ffffff;
            --header-bg: rgba(18, 18, 19, 0.8);
            --color-absent: #3a3a3c;
            --shadow-color: rgba(0, 0, 0, 0.4);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
        html, body { height: 100%; overscroll-behavior-y: contain; }
        body { font-family: var(--font-family); background-color: var(--bg-color); color: var(--text-color); display: flex; justify-content: center; align-items: center; transition: background-color 0.3s, color 0.3s; overflow: hidden; }
        #app { width: 100%; height: 100%; max-width: 500px; display: flex; flex-direction: column; justify-content: space-between; align-items: center; padding: 10px; }
        .hidden { display: none !important; }

        /* === ГЛАВНОЕ МЕНЮ И ЭКРАН ДРУГА === */
        #main-menu, #friend-game-screen { display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; text-align: center; width: 100%; padding: 10px; }
        #main-menu h1 { font-size: 3rem; font-weight: 800; letter-spacing: 0.1em; margin-bottom: 1rem; }
        #main-menu p { font-size: 1.1rem; margin-bottom: 2.5rem; color: var(--color-absent); }
        .length-selector { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; width: 100%; max-width: 380px; margin-bottom: 20px; }
        .menu-button { background-color: var(--key-bg); color: var(--key-text-color); font-family: var(--font-family); font-size: 1rem; font-weight: 700; border: none; padding: 20px 10px; border-radius: 8px; cursor: pointer; transition: background-color 0.2s, transform 0.2s; box-shadow: 0 2px 5px var(--shadow-color); user-select: none; }
        .menu-button:hover { transform: translateY(-2px); filter: brightness(1.1); }
        .friend-mode-button { background-color: var(--color-correct); color: var(--color-text-light); width: 100%; max-width: 380px; }
        .stats-button { background-color: var(--color-present); color: var(--color-text-light); width: 100%; max-width: 380px; margin-top: 15px; }
        .theme-switcher { position: absolute; bottom: 30px; display: flex; align-items: center; gap: 10px; cursor: pointer; }
        .theme-toggle { width: 50px; height: 26px; background-color: var(--key-bg); border-radius: 13px; position: relative; transition: background-color 0.3s; }
        .theme-toggle::before { content: ''; position: absolute; width: 20px; height: 20px; background-color: var(--bg-color); border-radius: 50%; top: 3px; left: 3px; transition: transform 0.3s ease; }
        [data-theme="dark"] .theme-toggle::before { transform: translateX(24px); }

        .friend-screen-container { text-align: center; display: flex; flex-direction: column; gap: 20px; width: 100%; max-width: 380px; }
        .friend-screen-container h2 { font-size: 1.8rem; margin-bottom: 10px; }
        .input-field { width: 100%; padding: 15px; font-size: 1.2rem; border-radius: 8px; border: 2px solid var(--tile-border-color); background-color: var(--tile-bg); color: var(--text-color); text-align: center; font-family: var(--font-family); }
        .input-field:focus { outline: none; border-color: var(--color-correct); }
        .code-display { padding: 20px; background-color: var(--bg-color); border: 2px dashed var(--tile-border-color); border-radius: 8px; font-family: monospace; font-size: 1.2rem; font-weight: 700; word-break: break-all; margin-bottom: 10px; }
        
        /* === ИГРОВОЙ ЭКРАН === */
        #game-screen { width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: space-between; }
        header { display: flex; justify-content: space-between; align-items: center; padding: 5px; position: relative; z-index: 10; width: 100%; flex-shrink: 0; }
        header h2 { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); font-size: 1.5rem; font-weight: 800; letter-spacing: 0.05em; text-align: center; pointer-events: none; }
        .icon-button { background: none; border: none; cursor: pointer; width: 48px; height: 48px; display: flex; justify-content: center; align-items: center; color: var(--text-color); font-size: 28px; }
        #game-board-container { display: flex; justify-content: center; align-items: center; flex-grow: 1; overflow: hidden; width: 100%; padding: 5px; }
        #game-board { display: grid; grid-template-rows: repeat(6, 1fr); gap: 5px; max-width: 100%; max-height: 100%; aspect-ratio: 5 / 6; }
        .board-row { display: grid; gap: 5px; }
        .tile { display: inline-flex; justify-content: center; align-items: center; border: 2px solid var(--tile-border-color); background-color: var(--tile-bg); font-size: 2rem; font-weight: 700; text-transform: uppercase; color: var(--tile-text-color); transition: transform 0.2s, background-color 0.3s, border-color 0.3s; transform-style: preserve-3d; }
        .tile.filled { border-color: #878a8c; }
        .tile.flip { animation: flip 0.6s ease forwards; }
        .tile.placeholder { color: color-mix(in srgb, var(--text-color) 40%, transparent); background-color: transparent; border-style: dashed; }
        @keyframes pop { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
        @keyframes flip { 0% { transform: rotateX(0deg); } 50% { transform: rotateX(90deg); } 100% { transform: rotateX(0deg); } }
        .tile.correct, .tile.present, .tile.absent { border: none; color: var(--color-text-light); }
        .tile.correct { background-color: var(--color-correct); }
        .tile.present { background-color: var(--color-present); }
        .tile.absent { background-color: var(--color-absent); }
        .row.shake { animation: shake 0.5s ease-in-out; }
        @keyframes shake { 10%, 90% { transform: translateX(-2px); } 20%, 80% { transform: translateX(4px); } 30%, 50%, 70% { transform: translateX(-6px); } 40%, 60% { transform: translateX(6px); } }
        .row.win { animation: bounce 0.8s ease-in-out; }
        @keyframes bounce { 0%, 20%, 50%, 80%, 100% {transform: translateY(0);} 40% {transform: translateY(-20px);} 60% {transform: translateY(-10px);} }

        /* === КЛАВИАТУРА === */
        #keyboard { width: 100%; padding: 5px 0; user-select: none; flex-shrink: 0; }
        .keyboard-row { display: flex; justify-content: center; margin: 0 auto 8px; gap: 6px; }
        .key { font-family: var(--font-family); font-weight: 600; background-color: var(--key-bg); color: var(--key-text-color); border: none; border-radius: 4px; cursor: pointer; display: flex; justify-content: center; align-items: center; text-transform: uppercase; height: 58px; flex: 1; font-size: 1rem; transition: background-color 0.2s, transform 0.1s; }
        .key.large { flex: 1.5; font-size: 0.8rem; }
        .key.pressed { transform: scale(0.95); filter: brightness(0.9); }
        .key.correct { background-color: var(--color-correct); color: var(--color-text-light); }
        .key.present { background-color: var(--color-present); color: var(--color-text-light); }
        .key.absent { background-color: var(--color-absent); color: var(--color-text-light); }
        @media (max-height: 720px) {
            .key { height: 48px; }
            header h2 { font-size: 1.3rem; }
        }
        @media (max-height: 650px) {
            .key { height: 42px; gap: 4px; }
            .keyboard-row { gap: 4px; }
        }
        
        /* === МОДАЛЬНЫЕ ОКНА === */
        .modal-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: var(--modal-bg); backdrop-filter: blur(5px); display: flex; justify-content: center; align-items: center; z-index: 1000; padding: 20px; }
        .modal-content { background-color: var(--tile-bg); padding: 20px; border-radius: 16px; box-shadow: 0 4px 20px var(--shadow-color); text-align: center; width: 100%; max-width: 520px; animation: fadeIn 0.3s ease; max-height: 90vh; overflow-y: auto; }
        .modal-content h3 { font-size: 2rem; margin-bottom: 20px; }
        .modal-content p { margin-bottom: 25px; font-size: 1.1rem; }
        .modal-buttons { display: flex; flex-direction: column; gap: 15px; }
        .modal-button { padding: 15px; border-radius: 8px; border: none; cursor: pointer; font-size: 1.1rem; font-weight: 700; font-family: var(--font-family); transition: transform 0.2s, filter 0.2s; user-select: none; }
        .modal-button:hover { transform: translateY(-2px); filter: brightness(1.05); }
        .primary { background-color: var(--color-correct); color: var(--color-text-light); }
        .secondary { background-color: var(--key-bg); color: var(--key-text-color); }
        #stats-container { display: flex; justify-content: space-around; margin-bottom: 20px; }
        .stat { display: flex; flex-direction: column; }
        .stat-value { font-size: 2rem; font-weight: 800; }
        .stat-label { font-size: 0.8rem; color: var(--color-absent); }

        /* === ТАБЛИЦА СТАТИСТИКИ === */
        #stats-table-container { width: 100%; }
        .stats-table { width: 100%; border-collapse: collapse; }
        .stats-table th, .stats-table td { padding: 12px 15px; text-align: center; border-bottom: 1px solid var(--tile-border-color); }
        .stats-table th { font-size: 0.9rem; font-weight: 700; color: var(--color-absent); }
        .stats-table td:first-child { font-weight: 700; text-align: left; }
        .stats-table tbody tr:last-child td { border-bottom: none; }

        @media screen and (max-width: 600px) {
            .stats-table table, .stats-table thead, .stats-table tbody, .stats-table th, .stats-table td, .stats-table tr { display: block; }
            .stats-table thead tr { position: absolute; top: -9999px; left: -9999px; }
            .stats-table tr { border: 1px solid var(--tile-border-color); margin-bottom: 1em; border-radius: 8px; }
            .stats-table td { border: none; border-bottom: 1px solid var(--bg-color); position: relative; padding-left: 50%; text-align: right; }
            .stats-table td:last-child { border-bottom: 0; }
            .stats-table td:before { content: attr(data-label); position: absolute; left: 15px; width: 45%; padding-right: 10px; white-space: nowrap; text-align: left; font-weight: bold; color: var(--color-absent); }
        }

        /* === УВЕДОМЛЕНИЕ (ТОСТ) === */
        #toast { position: fixed; top: 12%; left: 50%; transform: translateX(-50%); background-color: var(--text-color); color: var(--bg-color); padding: 12px 24px; border-radius: 20px; z-index: 2000; font-weight: 600; animation: toast-in-out 3s ease-in-out forwards; pointer-events: none; opacity: 0; }
        @keyframes toast-in-out {
            0% { transform: translate(-50%, -20px); opacity: 0; }
            15% { transform: translate(-50%, 0); opacity: 1; }
            85% { transform: translate(-50%, 0); opacity: 1; }
            100% { transform: translate(-50%, -20px); opacity: 0; }
        }
    </style>
</head>
<body data-theme="light">

    <div id="app">
        
        <div id="main-menu">
            <h1>WORDLE</h1>
            <p>Выберите длину слова</p>
            <div class="length-selector"></div>
            <button id="friend-mode-btn" class="menu-button friend-mode-button">Слово другу</button>
            <button id="stats-button" class="menu-button stats-button">Статистика</button>
            <div class="theme-switcher">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                <div class="theme-toggle"></div>
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
            </div>
        </div>

        <div id="friend-game-screen" class="hidden">
            <div id="friend-menu" class="friend-screen-container">
                <h2>Слово другу</h2>
                <button id="create-word-btn" class="menu-button primary">Загадать слово</button>
                <button id="guess-word-btn" class="menu-button secondary">Отгадать по коду</button>
                <button id="back-to-main-menu-btn" class="menu-button">Назад</button>
            </div>
            <div id="create-word-view" class="friend-screen-container hidden">
                <h2>Загадайте слово</h2>
                <p>Введите слово от 4 до 11 букв</p>
                <input type="text" id="word-to-create-input" class="input-field" maxlength="11" placeholder="Ваше слово...">
                <button id="generate-code-btn" class="menu-button primary">Сгенерировать код</button>
                 <button id="back-to-friend-menu-btn-1" class="menu-button">Назад</button>
            </div>
            <div id="display-code-view" class="friend-screen-container hidden">
                <h2>Ваш код готов!</h2>
                <p>Отправьте этот код другу:</p>
                <div id="generated-code-display" class="code-display"></div>
                <button id="copy-code-btn" class="menu-button primary">Копировать</button>
                <button id="back-to-friend-menu-btn-2" class="menu-button">Назад</button>
            </div>
            <div id="guess-word-view" class="friend-screen-container hidden">
                <h2>Отгадать слово</h2>
                <p>Вставьте код, который вам прислали</p>
                <input type="text" id="code-to-guess-input" class="input-field" placeholder="Код от друга...">
                <button id="start-guess-btn" class="menu-button primary">Начать игру</button>
                <button id="back-to-friend-menu-btn-3" class="menu-button">Назад</button>
            </div>
        </div>

        <div id="game-screen" class="hidden">
            <header>
                <button id="pause-button" class="icon-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
                </button>
                <h2 id="game-title">WORDLE</h2>
                <button id="hint-button" class="icon-button">💡</button>
            </header>
            <div id="game-board-container">
                <div id="game-board"></div>
            </div>
            <div id="keyboard"></div>
        </div>

        <div id="pause-modal" class="modal-overlay hidden">
            <div class="modal-content">
                <h3>Пауза</h3>
                <div class="modal-buttons">
                    <button id="resume-button" class="modal-button primary">Продолжить</button>
                    <button id="restart-button" class="modal-button secondary">Новая игра</button>
                    <button id="main-menu-button-from-pause" class="modal-button secondary">Главное меню</button>
                </div>
            </div>
        </div>
        
        <div id="endgame-modal" class="modal-overlay hidden">
            <div class="modal-content">
                <h3 id="endgame-title"></h3>
                <p>Загаданное слово: <b id="secret-word-display"></b></p>
                <div id="stats-container">
                    <div class="stat">
                        <span id="stat-played" class="stat-value">0</span>
                        <span class="stat-label">Сыграно</span>
                    </div>
                    <div class="stat">
                        <span id="stat-wins" class="stat-value">0</span>
                        <span class="stat-label">Побед (%)</span>
                    </div>
                    <div class="stat">
                        <span id="stat-streak" class="stat-value">0</span>
                        <span class="stat-label">Серия побед</span>
                    </div>
                </div>
                <div class="modal-buttons">
                    <button id="share-button" class="modal-button primary">Поделиться</button>
                    <button id="new-game-button" class="modal-button secondary">Играть снова</button>
                </div>
            </div>
        </div>

        <div id="stats-modal" class="modal-overlay hidden">
            <div class="modal-content">
                <h3>Статистика</h3>
                <div id="stats-table-container"></div>
                <div class="modal-buttons" style="margin-top: 20px;">
                    <button id="close-stats-btn" class="modal-button secondary">Закрыть</button>
                </div>
            </div>
        </div>
        
        <div id="toast" class="hidden"></div>

    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {

        const guessableWordsData = { "words": { "4": ["игра", "слон", "дом", "рука"], "5": ["слово", "буква", "книга", "ручка", "пилот"], "6": ["машина", "собака", "корова", "дорога"], "7": ["самолет", "телефон", "планета"], "8": ["компьютер", "программа", "клавиатура"], "9": ["библиотека", "технология"], "10": ["автомобиль", "температура"], "11": ["энциклопедия", "программист"] } };
        const validWordsData = { "words": { "4": ["игра", "слон", "дом", "рука", "нога", "река", "море", "поле", "лес", "шарф", "корт", "банк"], "5": ["слово", "буква", "книга", "ручка", "стол", "стул", "окно", "дверь", "лампа", "карта", "пилот", "завод", "посол", "колос", "трава"], "6": ["машина", "собака", "корова", "дорога", "школа", "работа", "ученик", "космос"], "7": ["самолет", "телефон", "планета", "человек", "корабль", "ракета"], "8": ["компьютер", "программа", "клавиатура", "разработчик"], "9": ["библиотека", "технология", "образование"], "10": ["автомобиль", "температура", "путешествие"], "11": ["энциклопедия", "программист", "достоинство"] } };
        const normalizeDict = (dict) => { for (const key in dict.words) { if (Object.hasOwnProperty.call(dict.words, key)) { dict.words[key] = dict.words[key].map(word => word.toLowerCase()); } } };
        normalizeDict(guessableWordsData);
        normalizeDict(validWordsData);

        const app = document.getElementById('app');
        const mainMenu = document.getElementById('main-menu');
        const lengthSelector = document.querySelector('.length-selector');
        const themeSwitcher = document.querySelector('.theme-switcher');
        const body = document.body;
        const gameScreen = document.getElementById('game-screen');
        const gameTitle = document.getElementById('game-title');
        const gameBoard = document.getElementById('game-board');
        const keyboardContainer = document.getElementById('keyboard');
        const pauseButton = document.getElementById('pause-button');
        const hintButton = document.getElementById('hint-button');
        const pauseModal = document.getElementById('pause-modal');
        const resumeButton = document.getElementById('resume-button');
        const restartButton = document.getElementById('restart-button');
        const mainMenuButtonFromPause = document.getElementById('main-menu-button-from-pause');
        const endgameModal = document.getElementById('endgame-modal');
        const endgameTitle = document.getElementById('endgame-title');
        const secretWordDisplay = document.getElementById('secret-word-display');
        const shareButton = document.getElementById('share-button');
        const newGameButton = document.getElementById('new-game-button');
        const statsContainer = document.getElementById('stats-container');
        const toast = document.getElementById('toast');
        const friendGameScreen = document.getElementById('friend-game-screen');
        const friendModeBtn = document.getElementById('friend-mode-btn');
        const statsButton = document.getElementById('stats-button');
        const statsModal = document.getElementById('stats-modal');
        const closeStatsBtn = document.getElementById('close-stats-btn');
        const friendMenu = document.getElementById('friend-menu');
        const createWordBtn = document.getElementById('create-word-btn');
        const guessWordBtn = document.getElementById('guess-word-btn');
        const backToMainMenuBtn = document.getElementById('back-to-main-menu-btn');
        const createWordView = document.getElementById('create-word-view');
        const wordToCreateInput = document.getElementById('word-to-create-input');
        const generateCodeBtn = document.getElementById('generate-code-btn');
        const displayCodeView = document.getElementById('display-code-view');
        const generatedCodeDisplay = document.getElementById('generated-code-display');
        const copyCodeBtn = document.getElementById('copy-code-btn');
        const guessWordView = document.getElementById('guess-word-view');
        const codeToGuessInput = document.getElementById('code-to-guess-input');
        const startGuessBtn = document.getElementById('start-guess-btn');

        document.getElementById('back-to-friend-menu-btn-1').addEventListener('click', () => showFriendScreen('menu'));
        document.getElementById('back-to-friend-menu-btn-2').addEventListener('click', () => showFriendScreen('menu'));
        document.getElementById('back-to-friend-menu-btn-3').addEventListener('click', () => showFriendScreen('menu'));
        
        let wordLength = 5;
        const maxGuesses = 6;
        let currentRowIndex = 0;
        let secretWord = '';
        let isGameOver = false;
        let isProcessing = false;
        let isFriendMode = false;
        let lastHintTimestamp = 0;
        let boardState = [];
        let shareableResult = [];
        let stats = {};
        let toastTimeout;
        const russianAlphabet = [ ['й', 'ц', 'у', 'к', 'е', 'н', 'г', 'ш', 'щ', 'з', 'х', 'ъ'], ['ф', 'ы', 'в', 'а', 'п', 'р', 'о', 'л', 'д', 'ж', 'э'], ['enter', 'я', 'ч', 'с', 'м', 'и', 'т', 'ь', 'б', 'ю', 'backspace'] ];
        let correctLetterPositions = [];

        function debounce(func, delay) { let timeout; return function(...args) { clearTimeout(timeout); timeout = setTimeout(() => func.apply(this, args), delay); }; }
        function encodeWord(word) { try { return btoa(encodeURIComponent(word)); } catch (e) { return null; } }
        function decodeWord(encoded) { try { return decodeURIComponent(atob(encoded)); } catch (e) { return null; } }

        function adjustGameHeight() {
            if (gameScreen.classList.contains('hidden')) return;
            createBoard();
        }

        function init() {
            loadTheme();
            loadLocalStats();
            createMainMenu();
            addEventListeners();
        }
        
        function createMainMenu() {
            lengthSelector.innerHTML = '';
            const availableLengths = Object.keys(guessableWordsData.words);
            availableLengths.forEach(len => {
                const button = document.createElement('button');
                button.className = 'menu-button';
                button.textContent = `${len} букв`;
                button.dataset.length = len;
                lengthSelector.appendChild(button);
            });
        }

        function startGame(length, customWord = null) {
            wordLength = parseInt(length);
            isFriendMode = customWord !== null;
            if (customWord) { secretWord = customWord.toLowerCase(); } 
            else {
                if (!guessableWordsData.words[wordLength] || guessableWordsData.words[wordLength].length === 0) {
                    showToast(`Нет слов для загадывания длины ${wordLength}`);
                    return;
                }
                const wordList = guessableWordsData.words[wordLength];
                secretWord = wordList[Math.floor(Math.random() * wordList.length)];
            }
            currentRowIndex = 0;
            isGameOver = false;
            isProcessing = false;
            boardState = Array(maxGuesses).fill(null).map(() => Array(wordLength).fill(''));
            shareableResult = [];
            correctLetterPositions = Array(wordLength).fill('');
            createBoard();
            createKeyboard();
            gameTitle.textContent = isFriendMode ? 'СЛОВО ОТ ДРУГА' : `СЛОВО ИЗ ${wordLength} БУКВ`;
            mainMenu.classList.add('hidden');
            friendGameScreen.classList.add('hidden');
            gameScreen.classList.remove('hidden');
            setTimeout(adjustGameHeight, 50);
        }

        function createBoard() {
            gameBoard.innerHTML = '';
            const container = document.getElementById('game-board-container');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            const boardRatio = wordLength / maxGuesses;
            
            let boardWidth = containerWidth;
            let boardHeight = boardWidth / boardRatio;

            if (boardHeight > containerHeight) {
                boardHeight = containerHeight;
                boardWidth = boardHeight * boardRatio;
            }
            
            gameBoard.style.width = `${boardWidth}px`;
            gameBoard.style.height = `${boardHeight}px`;
            
            gameBoard.style.gridTemplateRows = `repeat(${maxGuesses}, 1fr)`;
            for (let i = 0; i < maxGuesses; i++) {
                const row = document.createElement('div');
                row.className = 'board-row';
                row.style.gridTemplateColumns = `repeat(${wordLength}, 1fr)`;
                for (let j = 0; j < wordLength; j++) {
                    const tile = document.createElement('div');
                    tile.className = 'tile';
                    row.appendChild(tile);
                }
                gameBoard.appendChild(row);
            }
        }

        function createKeyboard() {
            keyboardContainer.innerHTML = '';
            russianAlphabet.forEach(row => {
                const keyboardRow = document.createElement('div');
                keyboardRow.className = 'keyboard-row';
                row.forEach(key => {
                    const keyElement = document.createElement('button');
                    keyElement.className = 'key';
                    keyElement.dataset.key = key;
                    if (key === 'enter') {
                        keyElement.classList.add('large');
                        keyElement.innerHTML = 'Ввод';
                    } else if (key === 'backspace') {
                        keyElement.classList.add('large');
                        keyElement.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"></path><line x1="18" y1="9" x2="12" y2="15"></line><line x1="12" y1="9" x2="18" y2="15"></line></svg>`;
                    } else { keyElement.textContent = key; }
                    keyboardRow.appendChild(keyElement);
                });
                keyboardContainer.appendChild(keyboardRow);
            });
        }

        function handleKeyPress(key) {
            if (isGameOver || isProcessing) return;
            key = key.toLowerCase();
            if (key === 'enter') { submitGuess(); } 
            else if (key === 'backspace' || key === 'delete') { deleteLetter(); } 
            else if (/^[а-яё]$/.test(key)) { addLetter(key === 'ё' ? 'е' : key); }
        }

        function addLetter(letter) {
            const firstEmptyIndex = boardState[currentRowIndex].indexOf('');
            if (firstEmptyIndex !== -1) {
                boardState[currentRowIndex][firstEmptyIndex] = letter;
                const tile = getTile(currentRowIndex, firstEmptyIndex);
                tile.textContent = letter;
                tile.classList.add('filled');
                tile.classList.remove('placeholder');
            }
        }

        function deleteLetter() {
            let lastFilledIndex = -1;
            for (let i = boardState[currentRowIndex].length - 1; i >= 0; i--) { if (boardState[currentRowIndex][i] !== '') { lastFilledIndex = i; break; } }
            if (lastFilledIndex !== -1) {
                boardState[currentRowIndex][lastFilledIndex] = '';
                const tile = getTile(currentRowIndex, lastFilledIndex);
                tile.textContent = '';
                tile.classList.remove('filled');
                if (correctLetterPositions[lastFilledIndex]) {
                    tile.textContent = correctLetterPositions[lastFilledIndex];
                    tile.classList.add('placeholder');
                }
            }
        }

        async function submitGuess() {
            if (boardState[currentRowIndex].includes('')) { showToast('Слишком короткое слово'); shakeRow(currentRowIndex); return; }
            const guess = boardState[currentRowIndex].join('');
            if (!isFriendMode && (!validWordsData.words[wordLength] || !validWordsData.words[wordLength].includes(guess))) {
                showToast('Слово не найдено в словаре');
                shakeRow(currentRowIndex);
                return;
            }
            isProcessing = true;
            const result = checkGuess(guess);
            await animateGuess(result);
            updateKeyboard(result);
            if (guess === secretWord) { winGame(); } 
            else if (currentRowIndex === maxGuesses - 1) { loseGame(); } 
            else { moveToNextRow(); }
            isProcessing = false;
        }

        function checkGuess(guess) {
            const result = Array(wordLength).fill('absent');
            const secretLetters = secretWord.split('');
            const guessLetters = guess.split('');
            for (let i = 0; i < wordLength; i++) {
                if (guessLetters[i] === secretLetters[i]) {
                    result[i] = 'correct';
                    secretLetters[i] = null;
                    correctLetterPositions[i] = guessLetters[i];
                }
            }
            for (let i = 0; i < wordLength; i++) {
                if (result[i] !== 'correct') {
                    const letterIndex = secretLetters.indexOf(guessLetters[i]);
                    if (letterIndex !== -1) {
                        result[i] = 'present';
                        secretLetters[letterIndex] = null;
                    }
                }
            }
            shareableResult.push(result);
            return result;
        }
        
        function moveToNextRow() { currentRowIndex++; projectPlaceholders(); }

        function projectPlaceholders() {
            if (currentRowIndex >= maxGuesses) return;
            for (let i = 0; i < wordLength; i++) {
                if (correctLetterPositions[i]) {
                    const tile = getTile(currentRowIndex, i);
                    tile.textContent = correctLetterPositions[i];
                    tile.classList.add('placeholder');
                }
            }
        }

        function showFriendScreen(view) {
            mainMenu.classList.add('hidden');
            gameScreen.classList.add('hidden');
            friendGameScreen.classList.remove('hidden');
            friendMenu.classList.add('hidden');
            createWordView.classList.add('hidden');
            displayCodeView.classList.add('hidden');
            guessWordView.classList.add('hidden');
            if (view === 'menu') friendMenu.classList.remove('hidden');
            if (view === 'create') createWordView.classList.remove('hidden');
            if (view === 'display') displayCodeView.classList.remove('hidden');
            if (view === 'guess') guessWordView.classList.remove('hidden');
        }

        function handleGenerateCode() {
            let word = wordToCreateInput.value.trim().toLowerCase();
            if (word.length < 4) { showToast('Слово слишком короткое'); return; }
            if (word.length > 11) { showToast('Слово слишком длинное'); return; }
            if (!/^[а-яё]+$/.test(word)) { showToast('Только русские буквы'); return; }
            const code = encodeWord(word);
            if (code) { generatedCodeDisplay.textContent = code; showFriendScreen('display'); } 
            else { showToast('Ошибка при создании кода'); }
        }

        function handleStartGuess() {
            const code = codeToGuessInput.value.trim();
            if (!code) { showToast('Введите код'); return; }
            const decodedWord = decodeWord(code);
            if (decodedWord) { startGame(decodedWord.length, decodedWord); } 
            else { showToast('Неверный код'); }
        }

        function handleHint() {
            if (isGameOver || isProcessing) return;
            const now = Date.now();
            if (now - lastHintTimestamp < 60000) {
                showToast(`Подсказка будет доступна через ${Math.ceil((60000 - (now - lastHintTimestamp)) / 1000)} сек.`);
                return;
            }
            const firstEmptyIndex = boardState[currentRowIndex].indexOf('');
            if (firstEmptyIndex === -1) { showToast('Ряд заполнен, подсказка невозможна'); return; }
            const hintLetter = secretWord[firstEmptyIndex];
            addLetter(hintLetter);
            const tile = getTile(currentRowIndex, firstEmptyIndex);
            tile.style.animation = 'pop 0.2s ease-in-out';
            tile.addEventListener('animationend', () => tile.style.animation = '', { once: true });
            lastHintTimestamp = now;
        }

        function winGame() {
            isGameOver = true;
            if (!isFriendMode) updateStats(true);
            setTimeout(() => {
                gameBoard.children[currentRowIndex].classList.add('win');
                endgameTitle.textContent = "Победа! 🎉";
                showEndGameModal();
            }, wordLength * 100 + 300);
        }
        
        function loseGame() {
            isGameOver = true;
            if (!isFriendMode) updateStats(false);
            setTimeout(() => {
                endgameTitle.textContent = "Увы, не угадали 😔";
                showEndGameModal();
            }, wordLength * 100 + 300);
        }
        
        function showEndGameModal() {
            secretWordDisplay.textContent = secretWord.toUpperCase();
            if (isFriendMode) { statsContainer.classList.add('hidden'); } 
            else {
                statsContainer.classList.remove('hidden');
                const currentStats = stats[wordLength] || { played: 0, wins: 0, currentStreak: 0 };
                document.getElementById('stat-played').textContent = currentStats.played;
                const winRate = currentStats.played > 0 ? Math.round((currentStats.wins / currentStats.played) * 100) : 0;
                document.getElementById('stat-wins').textContent = `${winRate}%`;
                document.getElementById('stat-streak').textContent = currentStats.currentStreak;
            }
            endgameModal.classList.remove('hidden');
        }

        function getTile(row, col) { return gameBoard.children[row].children[col]; }
        function shakeRow(rowIndex) {
            const row = gameBoard.children[rowIndex];
            row.classList.add('shake');
            row.addEventListener('animationend', () => row.classList.remove('shake'), { once: true });
        }

        async function animateGuess(result) {
            const row = gameBoard.children[currentRowIndex];
            for (let i = 0; i < wordLength; i++) {
                const tile = row.children[i];
                await new Promise(resolve => setTimeout(resolve, 100));
                tile.classList.add('flip');
                setTimeout(() => { tile.classList.add(result[i]); }, 300);
            }
            await new Promise(resolve => setTimeout(resolve, 600));
        }

        function updateKeyboard(result) {
            const guess = boardState[currentRowIndex];
            guess.forEach((letter, index) => {
                const key = keyboardContainer.querySelector(`[data-key="${letter}"]`);
                if (!key) return;
                const currentStatus = key.classList.contains('correct') ? 'correct' : key.classList.contains('present') ? 'present' : 'absent';
                const newStatus = result[index];
                if (newStatus === 'correct') { key.className = 'key correct'; } 
                else if (newStatus === 'present' && currentStatus !== 'correct') { key.className = 'key present'; } 
                else if (newStatus === 'absent' && currentStatus !== 'correct' && currentStatus !== 'present') { key.className = 'key absent'; }
            });
        }
        
        function showToast(message) {
            clearTimeout(toastTimeout);
            toast.textContent = message;
            toast.classList.remove('hidden');
            toast.style.animation = 'none';
            void toast.offsetWidth;
            toast.style.animation = 'toast-in-out 3s ease-in-out forwards';
        }
        
        function createShareableText() {
            const title = `Wordle ${currentRowIndex + (isGameOver && boardState[currentRowIndex].join('') === secretWord ? 0 : 1)}/6`;
            const emojiMap = { 'correct': '🟩', 'present': '🟨', 'absent': '⬜' };
            if (body.dataset.theme === 'dark') { emojiMap['absent'] = '⬛'; }
            const grid = shareableResult.map(row => row.map(status => emojiMap[status]).join('')).join('\n');
            return `${title}\n\n${grid}`;
        }
        
        function toggleTheme() {
            const newTheme = body.dataset.theme === 'light' ? 'dark' : 'light';
            body.dataset.theme = newTheme;
            localStorage.setItem('wordle-theme', newTheme);
        }

        function loadTheme() {
            const savedTheme = localStorage.getItem('wordle-theme') || (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');
            body.dataset.theme = savedTheme;
        }
        
        function updateStats(didWin) {
            if (!stats[wordLength]) { stats[wordLength] = { played: 0, wins: 0, currentStreak: 0 }; }
            const modeStats = stats[wordLength];
            modeStats.played++;
            if (didWin) { modeStats.wins++; modeStats.currentStreak++; } 
            else { modeStats.currentStreak = 0; }
            localStorage.setItem('wordle-stats', JSON.stringify(stats));
        }

        function loadLocalStats() {
            const localData = localStorage.getItem('wordle-stats');
            if (localData) { stats = JSON.parse(localData); }
        }

        function renderStatsTable() {
            const container = document.getElementById('stats-table-container');
            container.innerHTML = '';
            
            const table = document.createElement('table');
            table.className = 'stats-table';
            
            const headers = ['Режим', '% побед', 'Сыграно', 'Серия побед'];
            const thead = document.createElement('thead');
            const headerRow = document.createElement('tr');
            headers.forEach(text => {
                const th = document.createElement('th');
                th.textContent = text;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);
            table.appendChild(thead);

            const tbody = document.createElement('tbody');
            const availableLengths = Object.keys(guessableWordsData.words);

            availableLengths.forEach(len => {
                const modeStats = stats[len] || { played: 0, wins: 0, currentStreak: 0 };
                const tr = document.createElement('tr');
                
                const statsValues = {
                    'Режим': `${len} букв`,
                    '% побед': modeStats.played > 0 ? `${Math.round((modeStats.wins / modeStats.played) * 100)}%` : '—',
                    'Сыграно': modeStats.played > 0 ? modeStats.played : '—',
                    'Серия побед': modeStats.played > 0 ? modeStats.currentStreak : '—'
                };

                headers.forEach(header => {
                    const td = document.createElement('td');
                    td.textContent = statsValues[header];
                    td.dataset.label = header;
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            table.appendChild(tbody);
            container.appendChild(table);
        }


        function addEventListeners() {
            lengthSelector.addEventListener('click', e => { if (e.target.classList.contains('menu-button')) { startGame(e.target.dataset.length); } });
            friendModeBtn.addEventListener('click', () => showFriendScreen('menu'));
            statsButton.addEventListener('click', () => { renderStatsTable(); statsModal.classList.remove('hidden'); });
            closeStatsBtn.addEventListener('click', () => statsModal.classList.add('hidden'));
            backToMainMenuBtn.addEventListener('click', () => { friendGameScreen.classList.add('hidden'); mainMenu.classList.remove('hidden'); });
            createWordBtn.addEventListener('click', () => showFriendScreen('create'));
            guessWordBtn.addEventListener('click', () => showFriendScreen('guess'));
            generateCodeBtn.addEventListener('click', handleGenerateCode);
            copyCodeBtn.addEventListener('click', () => { navigator.clipboard.writeText(generatedCodeDisplay.textContent).then(() => showToast('Код скопирован!')); });
            startGuessBtn.addEventListener('click', handleStartGuess);
            themeSwitcher.addEventListener('click', toggleTheme);

            let activeKey = null;
            const handlePressStart = (e) => { if (e.target.closest('.key')) { activeKey = e.target.closest('.key'); activeKey.classList.add('pressed'); } };
            const handlePressEnd = (e) => {
                if (activeKey) {
                    const keyToProcess = activeKey.dataset.key;
                    activeKey.classList.remove('pressed');
                    handleKeyPress(keyToProcess);
                    activeKey = null;
                }
            };
            keyboardContainer.addEventListener('mousedown', handlePressStart);
            keyboardContainer.addEventListener('mouseup', handlePressEnd);
            keyboardContainer.addEventListener('mouseleave', () => { if (activeKey) { activeKey.classList.remove('pressed'); activeKey = null; } });
            keyboardContainer.addEventListener('touchstart', (e) => { e.preventDefault(); handlePressStart(e); }, { passive: false });
            keyboardContainer.addEventListener('touchend', (e) => { e.preventDefault(); handlePressEnd(e); }, { passive: false });

            document.addEventListener('keydown', e => { if (!gameScreen.classList.contains('hidden')) { handleKeyPress(e.key); } });
            
            pauseButton.addEventListener('click', () => pauseModal.classList.remove('hidden'));
            hintButton.addEventListener('click', handleHint);
            resumeButton.addEventListener('click', () => pauseModal.classList.add('hidden'));
            restartButton.addEventListener('click', () => { pauseModal.classList.add('hidden'); startGame(wordLength, isFriendMode ? secretWord : null); });
            mainMenuButtonFromPause.addEventListener('click', () => { pauseModal.classList.add('hidden'); gameScreen.classList.add('hidden'); mainMenu.classList.remove('hidden'); });
            newGameButton.addEventListener('click', () => { endgameModal.classList.add('hidden'); startGame(wordLength); });
            shareButton.addEventListener('click', () => { navigator.clipboard.writeText(createShareableText()).then(() => showToast('Результат скопирован!')); });
            window.addEventListener('resize', debounce(adjustGameHeight, 100));
        }
        
        init();
    });
    </script>
</body>
</html>
